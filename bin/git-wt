#!/usr/bin/env bash
# git-wt - Interactive TUI for git worktree management
# Usage: git-wt [OPTIONS] [BRANCH]
#
# Arguments:
#   BRANCH            Branch name to create/switch to worktree for (skips interactive selection)
#
# Options:
#   --scan-dir DIR    Directory to scan for git repos (default: ~/src)
#   -h, --help        Show this help message
#   -v, --version     Show version
#
# Behavior:
#   - If BRANCH provided: directly create/switch to worktree for that branch
#   - If in a worktree: shows banner with main checkout location
#   - If in a git repo: prompts to select/create worktree
#   - If NOT in a git repo: prompts to select repo from ~/src
#   - Worktrees created at: ../${repo}.worktrees/${branch}

set -euo pipefail

# Version - embedded by release-it during release process
GIT_WT_VERSION="v0.5.0"

# Get version: use git describe only if running from development repo
get_version() {
  local script_path="${BASH_SOURCE[0]}"
  # Resolve symlinks to get actual script location
  while [[ -L "$script_path" ]]; do
    local link_target
    link_target="$(readlink "$script_path")"
    if [[ "$link_target" == /* ]]; then
      script_path="$link_target"
    else
      script_path="$(dirname "$script_path")/$link_target"
    fi
  done
  local script_dir
  script_dir="$(cd "$(dirname "$script_path")/.." && pwd)"

  # Only use git describe if .git exists in repo root (development mode)
  if [[ -d "$script_dir/.git" ]]; then
    git -C "$script_dir" describe --tags --always 2>/dev/null || echo "$GIT_WT_VERSION"
  else
    echo "$GIT_WT_VERSION"
  fi
}

SCAN_DIR="${HOME}/src"
TARGET_BRANCH=""
UPDATE_CHECK_FILE="/tmp/git-wt-update-check-$$"
PR_CACHE_DIR="/tmp/git-wt-pr-cache-$$"
export PR_CACHE_DIR  # Export for fzf preview subshell

# ANSI color helpers (defined early for use in exit trap)
style_bold() { printf '\033[1m%s\033[0m\n' "$1"; }
style_warn() { printf '\033[38;5;214m%s\033[0m\n' "$1"; }
style_error() { printf '\033[38;5;196m%s\033[0m\n' "$1"; }
style_success() { printf '\033[38;5;82m%s\033[0m\n' "$1"; }
style_bold_error() { printf '\033[1;38;5;196m%s\033[0m\n' "$1"; }

# Background update check - runs asynchronously
check_for_updates() {
  local current_version="$1"
  # Strip leading 'v' if present for comparison
  current_version="${current_version#v}"

  # Skip if current version is 'dev' or empty
  if [[ -z "$current_version" ]] || [[ "$current_version" == "dev" ]]; then
    return
  fi

  # Check GitHub API for latest release (timeout after 2 seconds)
  local latest_info
  if latest_info=$(curl -sf --max-time 2 "https://api.github.com/repos/nsheaps/git-wt/releases/latest" 2>/dev/null); then
    local latest_version
    latest_version=$(echo "$latest_info" | grep -o '"tag_name": *"[^"]*"' | head -1 | sed 's/.*"tag_name": *"v\{0,1\}\([^"]*\)".*/\1/')

    if [[ -n "$latest_version" ]] && [[ "$latest_version" != "$current_version" ]]; then
      # Simple version comparison - check if latest is newer
      # This works for semver: compare as strings after normalizing
      if [[ "$(printf '%s\n%s' "$current_version" "$latest_version" | sort -V | tail -1)" == "$latest_version" ]] && \
         [[ "$current_version" != "$latest_version" ]]; then
        echo "UPDATE_AVAILABLE=$latest_version" > "$UPDATE_CHECK_FILE"
      fi
    fi
  fi
}

# Start background update check
CURRENT_VERSION=$(get_version)
check_for_updates "$CURRENT_VERSION" &
UPDATE_CHECK_PID=$!

# Cleanup and show update notification on exit
cleanup_and_notify() {
  # Cleanup PR cache directory
  rm -rf "$PR_CACHE_DIR" 2>/dev/null || true

  # Wait briefly for background check (non-blocking if already done)
  wait "$UPDATE_CHECK_PID" 2>/dev/null || true

  # Check if update is available
  if [[ -f "$UPDATE_CHECK_FILE" ]]; then
    local update_info
    update_info=$(cat "$UPDATE_CHECK_FILE" 2>/dev/null || true)
    rm -f "$UPDATE_CHECK_FILE" 2>/dev/null || true

    if [[ "$update_info" == UPDATE_AVAILABLE=* ]]; then
      local new_version="${update_info#UPDATE_AVAILABLE=}"
      echo ""
      style_warn "A new release of git-wt is available: ${CURRENT_VERSION#v} â†’ $new_version"
      echo "To upgrade, run: brew upgrade git-wt"
    fi
  fi
}
trap cleanup_and_notify EXIT

show_help() {
  sed -n '2,17p' "$0" | sed 's/^# //' | sed 's/^#//'
  exit 0
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --scan-dir) SCAN_DIR="$2"; shift 2 ;;
    -h|--help) show_help ;;
    -v|--version) echo "git-wt $(get_version)"; exit 0 ;;
    -*) echo "Unknown option: $1" >&2; show_help ;;
    *) TARGET_BRANCH="$1"; shift ;;
  esac
done

# Check for required tools
check_tool() {
  if ! command -v "$1" &>/dev/null; then
    echo "Error: $1 is required but not installed" >&2
    case "$1" in
      fzf) echo "Install with: brew install fzf" >&2 ;;
    esac
    exit 1
  fi
}

check_tool fzf
check_tool git

# Confirm prompt (returns 0 for yes, 1 for no)
confirm() {
  local prompt="${1:-Confirm?}"
  local result
  result=$(printf 'Yes\nNo' | fzf --header="$prompt" --height=5 --no-info)
  [[ "$result" == "Yes" ]]
}

# Text input prompt
input_prompt() {
  local placeholder="${1:-Enter value}"
  local result
  result=$(fzf --print-query --header="$placeholder" --height=3 --no-info < /dev/null 2>/dev/null | head -1)
  echo "$result"
}

# Function to find repos in a directory
find_repos_in_dir() {
  local dir="$1"
  if [[ -d "$dir" ]]; then
    find "$dir" -maxdepth 4 -name ".git" -type d 2>/dev/null | while read -r git_dir; do
      dirname "$git_dir"
    done
  fi
}

# Function to select a repo from available options
select_repo() {
  local repos=()

  echo ""
  style_bold "Not in a git repository"
  echo ""

  echo "Scanning $SCAN_DIR for git repos..."

  # Find repos
  while IFS= read -r repo_path; do
    if [[ -n "$repo_path" ]]; then
      repos+=("$repo_path")
    fi
  done < <(find_repos_in_dir "$SCAN_DIR")

  if [[ ${#repos[@]} -eq 0 ]]; then
    echo "No git repositories found in $SCAN_DIR" >&2
    exit 1
  fi

  # Let user select
  SELECTED_REPO=$(printf '%s\n' "${repos[@]}" | fzf --prompt="Select repository> ")
  if [[ -z "$SELECTED_REPO" ]]; then
    echo "Cancelled"
    exit 0
  fi
  echo "$SELECTED_REPO"
}

# Function to create/switch to worktree for a specific branch
switch_to_branch() {
  local branch="$1"
  local git_root="$2"
  local repo_name=$(basename "$git_root")

  # Check if branch exists locally
  local branch_exists_local=false
  if git -C "$git_root" show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null; then
    branch_exists_local=true
  fi

  # Check if branch exists on remote
  local branch_exists_remote=false
  local remote_ref=""
  if git -C "$git_root" show-ref --verify --quiet "refs/remotes/origin/$branch" 2>/dev/null; then
    branch_exists_remote=true
    remote_ref="origin/$branch"
  fi

  # Determine worktree path
  local safe_branch=$(echo "$branch" | tr '/' '-')
  local worktree_path="../${repo_name}.worktrees/${safe_branch}"

  # Check if worktree already exists
  local existing_worktree=""
  while IFS= read -r line; do
    local wt_path=$(echo "$line" | cut -d' ' -f1)
    local wt_branch=$(git -C "$wt_path" branch --show-current 2>/dev/null || echo "")
    if [[ "$wt_branch" == "$branch" ]]; then
      existing_worktree="$wt_path"
      break
    fi
  done < <(git -C "$git_root" worktree list --porcelain 2>/dev/null | grep "^worktree " | cut -d' ' -f2-)

  if [[ -n "$existing_worktree" ]]; then
    echo "Worktree for branch '$branch' already exists at: $existing_worktree"
    echo ""
    echo "WORKTREE_PATH=$existing_worktree"
    return 0
  fi

  # Create worktree directory
  mkdir -p "$(dirname "$git_root/$worktree_path")"

  if [[ "$branch_exists_local" == "true" ]]; then
    # Branch exists locally - create worktree for it
    git -C "$git_root" worktree add "$worktree_path" "$branch"
    echo "Created worktree at: $(cd "$git_root/$worktree_path" && pwd)"
    echo "Branch: $branch (existing local branch)"
  elif [[ "$branch_exists_remote" == "true" ]]; then
    # Branch exists on remote - create tracking worktree
    git -C "$git_root" worktree add --track -b "$branch" "$worktree_path" "$remote_ref"
    echo "Created worktree at: $(cd "$git_root/$worktree_path" && pwd)"
    echo "Branch: $branch (tracking $remote_ref)"
  else
    # Branch doesn't exist - create new branch
    local default_branch=$(git -C "$git_root" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")

    echo "Branch '$branch' not found locally or on remote."
    echo ""

    # Ask what to base it on
    local base_options=("$default_branch (default)" "other...")
    local base_selected=$(printf '%s\n' "${base_options[@]}" | fzf --header="Create new branch based on:" --height=5 --no-info)

    local base_branch="$default_branch"
    if [[ "$base_selected" == "other..."* ]]; then
      base_branch=$(git -C "$git_root" branch -a --format='%(refname:short)' | fzf --prompt="Select base branch> ")
    fi

    git -C "$git_root" worktree add -b "$branch" "$worktree_path" "$base_branch"
    echo "Created worktree at: $(cd "$git_root/$worktree_path" && pwd)"
    echo "Branch: $branch (new, based on $base_branch)"
  fi

  echo ""
  echo "WORKTREE_PATH=$(cd "$git_root/$worktree_path" && pwd)"
}

# Check if we're in a git repository
IN_GIT_REPO=false
GIT_ROOT=""

if git rev-parse --git-dir &>/dev/null; then
  IN_GIT_REPO=true
  GIT_ROOT=$(git rev-parse --show-toplevel)
fi

# If not in a git repo, prompt to find one
if [[ "$IN_GIT_REPO" == "false" ]]; then
  GIT_ROOT=$(select_repo)
  if [[ -z "$GIT_ROOT" ]] || [[ ! -d "$GIT_ROOT" ]]; then
    echo "No repository selected"
    exit 1
  fi
  IN_GIT_REPO=true
  cd "$GIT_ROOT"
fi

# Get repo info
REPO_NAME=$(basename "$GIT_ROOT")

# Check if we're in a worktree (not the main checkout)
GIT_DIR=$(git -C "$GIT_ROOT" rev-parse --git-dir)
if [[ "$GIT_DIR" == *".git/worktrees/"* ]]; then
  # We're in a worktree - find the main checkout and use that for operations
  MAIN_CHECKOUT=$(git -C "$GIT_ROOT" rev-parse --path-format=absolute --git-common-dir | sed 's|/.git$||')
  GIT_ROOT="$MAIN_CHECKOUT"
  REPO_NAME=$(basename "$GIT_ROOT")
fi

# Fetch from remote first
echo ""
echo "Fetching from remote..."
git -C "$GIT_ROOT" fetch origin --prune 2>/dev/null || true

# Setup for PR preview caching
mkdir -p "$PR_CACHE_DIR"
export GIT_ROOT  # Export for fzf preview subshell

# If branch specified, directly create/switch to that worktree
if [[ -n "$TARGET_BRANCH" ]]; then
  echo ""
  style_bold "Switching to worktree for: $TARGET_BRANCH"
  echo ""

  switch_to_branch "$TARGET_BRANCH" "$GIT_ROOT"
  exit 0
fi

# Interactive mode - offer worktree selection
echo ""
style_bold "Git Worktree Selector"
echo ""

# Get existing worktrees (including root checkout) and track their branches
WORKTREES=()
ROOT_CHECKOUT=""
declare -A WORKTREE_BRANCHES
while IFS= read -r line; do
  # Track root checkout separately so it appears first
  if [[ "$line" == "$GIT_ROOT" ]]; then
    ROOT_CHECKOUT="$line"
  else
    WORKTREES+=("$line")
  fi
  # Track which branch this worktree is on for deduplication
  local_branch=$(git -C "$line" branch --show-current 2>/dev/null || echo "")
  if [[ -n "$local_branch" ]]; then
    WORKTREE_BRANCHES["$local_branch"]=1
  fi
done < <(git -C "$GIT_ROOT" worktree list --porcelain | grep "^worktree " | cut -d' ' -f2-)

# Build branch list from local branches only (excluding branches with existing worktrees)
declare -A BRANCHES

# Get local branches
while IFS= read -r branch; do
  if [[ -n "$branch" ]] && [[ -z "${WORKTREE_BRANCHES[$branch]:-}" ]]; then
    BRANCHES["$branch"]=1
  fi
done < <(git -C "$GIT_ROOT" branch --format='%(refname:short)' 2>/dev/null || echo "")

# Build menu options
MENU_OPTIONS=()
MENU_OPTIONS+=("ðŸ“ (create new worktree)")

# Add root checkout first (if found)
if [[ -n "$ROOT_CHECKOUT" ]]; then
  root_branch=$(git -C "$ROOT_CHECKOUT" branch --show-current 2>/dev/null || echo "detached")
  MENU_OPTIONS+=("ðŸ  [root] $root_branch â†’ $ROOT_CHECKOUT")
fi

# Add existing worktrees
for wt in "${WORKTREES[@]}"; do
  wt_branch=$(git -C "$wt" branch --show-current 2>/dev/null || echo "detached")
  MENU_OPTIONS+=("ðŸ“‚ [worktree] $wt_branch â†’ $wt")
done

# Add branches (sorted)
for branch in $(echo "${!BRANCHES[@]}" | tr ' ' '\n' | sort); do
  MENU_OPTIONS+=("$branch")
done

# Add option to switch repo (step "up")
MENU_OPTIONS+=("ðŸ”„ (switch repository)")

# Show selection menu with fzf
# Preview shows PR info from cache, falls back to single fetch if not cached yet
KEY_PRESSED=""
FZF_RESULT=$(printf '%s\n' "${MENU_OPTIONS[@]}" | fzf \
  --style=full \
  --expect=d \
  --no-sort \
  --header="enter=select, d=delete worktree" \
  --prompt="Select or create worktree> " \
  --preview='
    item={}
    # Extract branch name from different formats
    if [[ "$item" == "ðŸ“‚ [worktree]"* ]] || [[ "$item" == "ðŸ  [root]"* ]]; then
      branch=$(echo "$item" | sed "s/^[^ ]* \[[^]]*\] //" | sed "s/ â†’.*//")
    elif [[ "$item" == "ðŸ“"* ]] || [[ "$item" == "ðŸ”„"* ]]; then
      echo "No preview available"
      exit 0
    else
      branch="$item"
    fi

    # Read from cache if available
    safe_branch=$(echo "$branch" | tr "/" "_")
    cache_file="$PR_CACHE_DIR/$safe_branch"

    if [[ -f "$cache_file" ]]; then
      cat "$cache_file"
    elif command -v gh &>/dev/null; then
      # Cache miss - fetch just this branch from correct repo context
      cd "$GIT_ROOT" 2>/dev/null || true
      result=$(gh pr view "$branch" 2>&1)
      if [[ $? -eq 0 ]]; then
        echo "$result" | tee "$cache_file"
      else
        echo "No PR found for branch: $branch" | tee "$cache_file"
      fi
    else
      echo "No PR found for branch: $branch"
    fi
  ' \
  --preview-window=right:50%:wrap)
KEY_PRESSED=$(echo "$FZF_RESULT" | head -1)
SELECTED=$(echo "$FZF_RESULT" | tail -1)

if [[ -z "$SELECTED" ]]; then
  echo "Cancelled"
  exit 0
fi

# Handle 'd' key press for delete
if [[ "$KEY_PRESSED" == "d" ]]; then
  # Only allow deleting worktrees (not root, not create option, not branches)
  if [[ "$SELECTED" != "ðŸ“‚ [worktree]"* ]]; then
    echo ""
    style_warn "Cannot delete: only worktrees can be deleted with 'd'"
    echo "Selected item: $SELECTED"
    exit 1
  fi

  # Extract worktree path
  WT_PATH=$(echo "$SELECTED" | sed 's/.*â†’ //')
  WT_BRANCH=$(echo "$SELECTED" | sed 's/ðŸ“‚ \[worktree\] //' | sed 's/ â†’.*//')

  echo ""
  style_bold_error "Delete Worktree"
  echo ""
  echo "Branch: $WT_BRANCH"
  echo "Path: $WT_PATH"
  echo ""

  if confirm "Are you sure you want to delete this worktree?"; then
    # Remove the worktree
    if git -C "$GIT_ROOT" worktree remove "$WT_PATH" 2>/dev/null; then
      echo ""
      style_success "âœ“ Worktree deleted successfully"
    else
      # Try force remove if normal remove fails
      echo ""
      style_warn "Worktree has uncommitted changes or other issues."
      if confirm "Force delete? (will discard any uncommitted changes)"; then
        git -C "$GIT_ROOT" worktree remove --force "$WT_PATH"
        style_success "âœ“ Worktree force deleted"
      else
        echo "Cancelled"
      fi
    fi
  else
    echo "Cancelled"
  fi
  exit 0
fi

# Handle selection
case "$SELECTED" in
  "ðŸ“ (create new worktree)")
    # Get branch name
    BRANCH_NAME=$(input_prompt "Enter new branch name")
    if [[ -z "$BRANCH_NAME" ]]; then
      echo "Cancelled"
      exit 0
    fi

    # Ask for base branch
    CURRENT_BRANCH=$(git -C "$GIT_ROOT" branch --show-current)
    DEFAULT_BRANCH=$(git -C "$GIT_ROOT" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")

    BASE_OPTIONS=("$DEFAULT_BRANCH (default)" "$CURRENT_BRANCH (current)" "other...")
    BASE_SELECTED=$(printf '%s\n' "${BASE_OPTIONS[@]}" | fzf --header="Base branch:" --height=6 --no-info)

    case "$BASE_SELECTED" in
      *"(default)"*) BASE_BRANCH="$DEFAULT_BRANCH" ;;
      *"(current)"*) BASE_BRANCH="$CURRENT_BRANCH" ;;
      *) BASE_BRANCH=$(git -C "$GIT_ROOT" branch -a --format='%(refname:short)' | fzf --prompt="Select base branch> ") ;;
    esac

    # Create worktree path
    SAFE_BRANCH=$(echo "$BRANCH_NAME" | tr '/' '-')
    WORKTREE_PATH="../${REPO_NAME}.worktrees/${SAFE_BRANCH}"

    # Create the worktree
    mkdir -p "$(dirname "$GIT_ROOT/$WORKTREE_PATH")"
    git -C "$GIT_ROOT" worktree add -b "$BRANCH_NAME" "$WORKTREE_PATH" "$BASE_BRANCH"

    FINAL_PATH="$(cd "$GIT_ROOT/$WORKTREE_PATH" && pwd)"
    echo ""
    echo "Created worktree at: $FINAL_PATH"
    echo "Branch: $BRANCH_NAME (based on $BASE_BRANCH)"
    ;;

  "ðŸ  [root]"*)
    # Extract path from selection
    FINAL_PATH=$(echo "$SELECTED" | sed 's/.*â†’ //')
    echo ""
    echo "Selected root checkout: $FINAL_PATH"
    ;;

  "ðŸ“‚ [worktree]"*)
    # Extract path from selection
    FINAL_PATH=$(echo "$SELECTED" | sed 's/.*â†’ //')
    echo ""
    echo "Selected worktree: $FINAL_PATH"
    ;;

  "ðŸ”„ (switch repository)")
    # Reset and re-run with repo selection
    NEW_REPO=$(select_repo)
    if [[ -n "$NEW_REPO" ]] && [[ -d "$NEW_REPO" ]]; then
      exec "$0" --scan-dir "$SCAN_DIR"
    fi
    ;;

  *)
    # Selected an existing branch - create worktree for it
    BRANCH_NAME="$SELECTED"

    SAFE_BRANCH=$(echo "$BRANCH_NAME" | tr '/' '-')
    WORKTREE_PATH="../${REPO_NAME}.worktrees/${SAFE_BRANCH}"

    if [[ -d "$GIT_ROOT/$WORKTREE_PATH" ]]; then
      FINAL_PATH="$(cd "$GIT_ROOT/$WORKTREE_PATH" && pwd)"
      echo "Worktree already exists at: $FINAL_PATH"
    else
      mkdir -p "$(dirname "$GIT_ROOT/$WORKTREE_PATH")"

      # Check if branch exists locally or only on remote
      if git -C "$GIT_ROOT" show-ref --verify --quiet "refs/heads/$BRANCH_NAME" 2>/dev/null; then
        git -C "$GIT_ROOT" worktree add "$WORKTREE_PATH" "$BRANCH_NAME"
      elif git -C "$GIT_ROOT" show-ref --verify --quiet "refs/remotes/origin/$BRANCH_NAME" 2>/dev/null; then
        git -C "$GIT_ROOT" worktree add --track -b "$BRANCH_NAME" "$WORKTREE_PATH" "origin/$BRANCH_NAME"
      else
        git -C "$GIT_ROOT" worktree add "$WORKTREE_PATH" "$BRANCH_NAME"
      fi
      FINAL_PATH="$(cd "$GIT_ROOT/$WORKTREE_PATH" && pwd)"
      echo "Created worktree at: $FINAL_PATH"
    fi

    echo "Branch: $BRANCH_NAME"
    ;;
esac

# Change to worktree directory and start new shell
if [[ -n "${FINAL_PATH:-}" ]] && [[ -d "$FINAL_PATH" ]]; then
  echo ""
  echo "Changing to: $FINAL_PATH"
  cd "$FINAL_PATH" && exec "$SHELL"
fi
