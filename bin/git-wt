#!/usr/bin/env bash
# git-wt - Interactive TUI for git worktree management
# Usage: git-wt [OPTIONS] [BRANCH]
#
# Arguments:
#   BRANCH            Branch name to create/switch to worktree for (skips interactive selection)
#
# Options:
#   --scan-dir DIR    Directory to scan for git repos (default: ~/src)
#   -h, --help        Show this help message
#   -v, --version     Show version
#
# Behavior:
#   - If BRANCH provided: directly create/switch to worktree for that branch
#   - If in a worktree: shows banner with main checkout location
#   - If in a git repo: prompts to select/create worktree
#   - If NOT in a git repo: prompts to select repo from ~/src
#   - Worktrees created at: ../${repo}.worktrees/${branch}

set -euo pipefail

# Version is replaced at release time by CI. For local dev, falls back to git describe.
GIT_WT_VERSION="v0.4.8"

# Get version: use embedded version if set, otherwise fall back to git describe for local dev
get_version() {
  if [[ "$GIT_WT_VERSION" != __"VERSION"__ ]]; then
    echo "$GIT_WT_VERSION"
  else
    git describe --tags --always 2>/dev/null || echo 'dev'
  fi
}

SCAN_DIR="${HOME}/src"
TARGET_BRANCH=""
UPDATE_CHECK_FILE="/tmp/git-wt-update-check-$$"

# Background update check - runs asynchronously
check_for_updates() {
  local current_version="$1"
  # Strip leading 'v' if present for comparison
  current_version="${current_version#v}"

  # Skip if current version is 'dev' or empty
  if [[ -z "$current_version" ]] || [[ "$current_version" == "dev" ]]; then
    return
  fi

  # Check GitHub API for latest release (timeout after 2 seconds)
  local latest_info
  if latest_info=$(curl -sf --max-time 2 "https://api.github.com/repos/nsheaps/git-wt/releases/latest" 2>/dev/null); then
    local latest_version
    latest_version=$(echo "$latest_info" | grep -o '"tag_name": *"[^"]*"' | head -1 | sed 's/.*"tag_name": *"v\{0,1\}\([^"]*\)".*/\1/')

    if [[ -n "$latest_version" ]] && [[ "$latest_version" != "$current_version" ]]; then
      # Simple version comparison - check if latest is newer
      # This works for semver: compare as strings after normalizing
      if [[ "$(printf '%s\n%s' "$current_version" "$latest_version" | sort -V | tail -1)" == "$latest_version" ]] && \
         [[ "$current_version" != "$latest_version" ]]; then
        echo "UPDATE_AVAILABLE=$latest_version" > "$UPDATE_CHECK_FILE"
      fi
    fi
  fi
}

# Start background update check
CURRENT_VERSION=$(get_version)
check_for_updates "$CURRENT_VERSION" &
UPDATE_CHECK_PID=$!

# Cleanup and show update notification on exit
show_update_notification() {
  # Wait briefly for background check (non-blocking if already done)
  wait "$UPDATE_CHECK_PID" 2>/dev/null || true

  # Check if update is available
  if [[ -f "$UPDATE_CHECK_FILE" ]]; then
    local update_info
    update_info=$(cat "$UPDATE_CHECK_FILE" 2>/dev/null || true)
    rm -f "$UPDATE_CHECK_FILE" 2>/dev/null || true

    if [[ "$update_info" == UPDATE_AVAILABLE=* ]]; then
      local new_version="${update_info#UPDATE_AVAILABLE=}"
      echo ""
      gum style --foreground 214 "A new release of git-wt is available: ${CURRENT_VERSION#v} â†’ $new_version"
      echo "To upgrade, run: brew upgrade git-wt"
    fi
  fi
}
trap show_update_notification EXIT

show_help() {
  sed -n '2,17p' "$0" | sed 's/^# //' | sed 's/^#//'
  exit 0
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --scan-dir) SCAN_DIR="$2"; shift 2 ;;
    -h|--help) show_help ;;
    -v|--version) echo "git-wt $(get_version)"; exit 0 ;;
    -*) echo "Unknown option: $1" >&2; show_help ;;
    *) TARGET_BRANCH="$1"; shift ;;
  esac
done

# Check for required tools
check_tool() {
  if ! command -v "$1" &>/dev/null; then
    echo "Error: $1 is required but not installed" >&2
    case "$1" in
      gum) echo "Install with: brew install gum" >&2 ;;
    esac
    exit 1
  fi
}

check_tool gum
check_tool git

# Function to find repos in a directory
find_repos_in_dir() {
  local dir="$1"
  if [[ -d "$dir" ]]; then
    find "$dir" -maxdepth 4 -name ".git" -type d 2>/dev/null | while read -r git_dir; do
      dirname "$git_dir"
    done
  fi
}

# Function to select a repo from available options
select_repo() {
  local repos=()

  echo ""
  gum style --bold "Not in a git repository"
  echo ""

  echo ""
  gum spin --title "Scanning $SCAN_DIR for git repos..." -- sleep 0.5

  # Find repos
  while IFS= read -r repo_path; do
    if [[ -n "$repo_path" ]]; then
      repos+=("$repo_path")
    fi
  done < <(find_repos_in_dir "$SCAN_DIR")

  if [[ ${#repos[@]} -eq 0 ]]; then
    echo "No git repositories found in $SCAN_DIR" >&2
    exit 1
  fi

  # Let user select
  SELECTED_REPO=$(printf '%s\n' "${repos[@]}" | gum filter --placeholder "Select repository...")
  if [[ -z "$SELECTED_REPO" ]]; then
    echo "Cancelled"
    exit 0
  fi
  echo "$SELECTED_REPO"
}

# Function to create/switch to worktree for a specific branch
switch_to_branch() {
  local branch="$1"
  local git_root="$2"
  local repo_name=$(basename "$git_root")

  # Check if branch exists locally
  local branch_exists_local=false
  if git -C "$git_root" show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null; then
    branch_exists_local=true
  fi

  # Check if branch exists on remote
  local branch_exists_remote=false
  local remote_ref=""
  if git -C "$git_root" show-ref --verify --quiet "refs/remotes/origin/$branch" 2>/dev/null; then
    branch_exists_remote=true
    remote_ref="origin/$branch"
  fi

  # Determine worktree path
  local safe_branch=$(echo "$branch" | tr '/' '-')
  local worktree_path="../${repo_name}.worktrees/${safe_branch}"

  # Check if worktree already exists
  local existing_worktree=""
  while IFS= read -r line; do
    local wt_path=$(echo "$line" | cut -d' ' -f1)
    local wt_branch=$(git -C "$wt_path" branch --show-current 2>/dev/null || echo "")
    if [[ "$wt_branch" == "$branch" ]]; then
      existing_worktree="$wt_path"
      break
    fi
  done < <(git -C "$git_root" worktree list --porcelain 2>/dev/null | grep "^worktree " | cut -d' ' -f2-)

  if [[ -n "$existing_worktree" ]]; then
    echo "Worktree for branch '$branch' already exists at: $existing_worktree"
    echo ""
    echo "WORKTREE_PATH=$existing_worktree"
    return 0
  fi

  # Create worktree directory
  mkdir -p "$(dirname "$git_root/$worktree_path")"

  if [[ "$branch_exists_local" == "true" ]]; then
    # Branch exists locally - create worktree for it
    git -C "$git_root" worktree add "$worktree_path" "$branch"
    echo "Created worktree at: $(cd "$git_root/$worktree_path" && pwd)"
    echo "Branch: $branch (existing local branch)"
  elif [[ "$branch_exists_remote" == "true" ]]; then
    # Branch exists on remote - create tracking worktree
    git -C "$git_root" worktree add --track -b "$branch" "$worktree_path" "$remote_ref"
    echo "Created worktree at: $(cd "$git_root/$worktree_path" && pwd)"
    echo "Branch: $branch (tracking $remote_ref)"
  else
    # Branch doesn't exist - create new branch
    local default_branch=$(git -C "$git_root" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")

    echo "Branch '$branch' not found locally or on remote."
    echo ""

    # Ask what to base it on
    local base_options=("$default_branch (default)" "other...")
    local base_selected=$(printf '%s\n' "${base_options[@]}" | gum choose --header "Create new branch based on:")

    local base_branch="$default_branch"
    if [[ "$base_selected" == "other..."* ]]; then
      base_branch=$(git -C "$git_root" branch -a --format='%(refname:short)' | gum filter --placeholder "Select base branch...")
    fi

    git -C "$git_root" worktree add -b "$branch" "$worktree_path" "$base_branch"
    echo "Created worktree at: $(cd "$git_root/$worktree_path" && pwd)"
    echo "Branch: $branch (new, based on $base_branch)"
  fi

  echo ""
  echo "WORKTREE_PATH=$(cd "$git_root/$worktree_path" && pwd)"
}

# Check if we're in a git repository
IN_GIT_REPO=false
GIT_ROOT=""

if git rev-parse --git-dir &>/dev/null; then
  IN_GIT_REPO=true
  GIT_ROOT=$(git rev-parse --show-toplevel)
fi

# If not in a git repo, prompt to find one
if [[ "$IN_GIT_REPO" == "false" ]]; then
  GIT_ROOT=$(select_repo)
  if [[ -z "$GIT_ROOT" ]] || [[ ! -d "$GIT_ROOT" ]]; then
    echo "No repository selected"
    exit 1
  fi
  IN_GIT_REPO=true
  cd "$GIT_ROOT"
fi

# Get repo info
REPO_NAME=$(basename "$GIT_ROOT")

# Check if we're in a worktree (not the main checkout)
GIT_DIR=$(git -C "$GIT_ROOT" rev-parse --git-dir)
if [[ "$GIT_DIR" == *".git/worktrees/"* ]]; then
  # We're in a worktree - find the main checkout and use that for operations
  MAIN_CHECKOUT=$(git -C "$GIT_ROOT" rev-parse --path-format=absolute --git-common-dir | sed 's|/.git$||')
  GIT_ROOT="$MAIN_CHECKOUT"
  REPO_NAME=$(basename "$GIT_ROOT")
fi

# Fetch from remote first
echo ""
gum spin --title "Fetching from remote..." -- git -C "$GIT_ROOT" fetch origin --prune 2>/dev/null || true

# If branch specified, directly create/switch to that worktree
if [[ -n "$TARGET_BRANCH" ]]; then
  echo ""
  gum style --bold "Switching to worktree for: $TARGET_BRANCH"
  echo ""

  switch_to_branch "$TARGET_BRANCH" "$GIT_ROOT"
  exit 0
fi

# Interactive mode - offer worktree selection
echo ""
gum style --bold "Git Worktree Selector"
echo ""

# Get existing worktrees (excluding main) and track their branches
WORKTREES=()
declare -A WORKTREE_BRANCHES
while IFS= read -r line; do
  # Skip the main worktree
  if [[ "$line" != "$GIT_ROOT" ]]; then
    WORKTREES+=("$line")
    # Track which branch this worktree is on for deduplication
    local_branch=$(git -C "$line" branch --show-current 2>/dev/null || echo "")
    if [[ -n "$local_branch" ]]; then
      WORKTREE_BRANCHES["$local_branch"]=1
    fi
  fi
done < <(git -C "$GIT_ROOT" worktree list --porcelain | grep "^worktree " | cut -d' ' -f2-)

# Build branch list from local branches only (excluding branches with existing worktrees)
declare -A BRANCHES

# Get local branches
while IFS= read -r branch; do
  if [[ -n "$branch" ]] && [[ -z "${WORKTREE_BRANCHES[$branch]:-}" ]]; then
    BRANCHES["$branch"]=1
  fi
done < <(git -C "$GIT_ROOT" branch --format='%(refname:short)' 2>/dev/null || echo "")

# Build menu options
MENU_OPTIONS=()
MENU_OPTIONS+=("ðŸ“ (create new worktree)")

# Add existing worktrees first
for wt in "${WORKTREES[@]}"; do
  wt_branch=$(git -C "$wt" branch --show-current 2>/dev/null || echo "detached")
  MENU_OPTIONS+=("ðŸ“‚ [existing] $wt_branch â†’ $wt")
done

# Add branches (sorted)
for branch in $(echo "${!BRANCHES[@]}" | tr ' ' '\n' | sort); do
  MENU_OPTIONS+=("$branch")
done

# Add option to switch repo (step "up")
MENU_OPTIONS+=("ðŸ”„ (switch repository)")

# Show selection menu (--no-sort keeps existing worktrees at top while filtering)
SELECTED=$(printf '%s\n' "${MENU_OPTIONS[@]}" | gum filter --no-sort --placeholder "Select or create worktree...")

if [[ -z "$SELECTED" ]]; then
  echo "Cancelled"
  exit 0
fi

# Handle selection
case "$SELECTED" in
  "ðŸ“ (create new worktree)")
    # Get branch name
    BRANCH_NAME=$(gum input --placeholder "Enter new branch name...")
    if [[ -z "$BRANCH_NAME" ]]; then
      echo "Cancelled"
      exit 0
    fi

    # Ask for base branch
    CURRENT_BRANCH=$(git -C "$GIT_ROOT" branch --show-current)
    DEFAULT_BRANCH=$(git -C "$GIT_ROOT" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")

    BASE_OPTIONS=("$DEFAULT_BRANCH (default)" "$CURRENT_BRANCH (current)" "other...")
    BASE_SELECTED=$(printf '%s\n' "${BASE_OPTIONS[@]}" | gum choose --header "Base branch:")

    case "$BASE_SELECTED" in
      *"(default)"*) BASE_BRANCH="$DEFAULT_BRANCH" ;;
      *"(current)"*) BASE_BRANCH="$CURRENT_BRANCH" ;;
      *) BASE_BRANCH=$(git -C "$GIT_ROOT" branch -a --format='%(refname:short)' | gum filter --placeholder "Select base branch...") ;;
    esac

    # Create worktree path
    SAFE_BRANCH=$(echo "$BRANCH_NAME" | tr '/' '-')
    WORKTREE_PATH="../${REPO_NAME}.worktrees/${SAFE_BRANCH}"

    # Create the worktree
    mkdir -p "$(dirname "$GIT_ROOT/$WORKTREE_PATH")"
    git -C "$GIT_ROOT" worktree add -b "$BRANCH_NAME" "$WORKTREE_PATH" "$BASE_BRANCH"

    FINAL_PATH="$(cd "$GIT_ROOT/$WORKTREE_PATH" && pwd)"
    echo ""
    echo "Created worktree at: $FINAL_PATH"
    echo "Branch: $BRANCH_NAME (based on $BASE_BRANCH)"
    ;;

  "ðŸ“‚ [existing]"*)
    # Extract path from selection
    FINAL_PATH=$(echo "$SELECTED" | sed 's/.*â†’ //')
    echo ""
    echo "Selected existing worktree: $FINAL_PATH"
    ;;

  "ðŸ”„ (switch repository)")
    # Reset and re-run with repo selection
    NEW_REPO=$(select_repo)
    if [[ -n "$NEW_REPO" ]] && [[ -d "$NEW_REPO" ]]; then
      exec "$0" --scan-dir "$SCAN_DIR"
    fi
    ;;

  *)
    # Selected an existing branch - create worktree for it
    BRANCH_NAME="$SELECTED"

    SAFE_BRANCH=$(echo "$BRANCH_NAME" | tr '/' '-')
    WORKTREE_PATH="../${REPO_NAME}.worktrees/${SAFE_BRANCH}"

    if [[ -d "$GIT_ROOT/$WORKTREE_PATH" ]]; then
      FINAL_PATH="$(cd "$GIT_ROOT/$WORKTREE_PATH" && pwd)"
      echo "Worktree already exists at: $FINAL_PATH"
    else
      mkdir -p "$(dirname "$GIT_ROOT/$WORKTREE_PATH")"

      # Check if branch exists locally or only on remote
      if git -C "$GIT_ROOT" show-ref --verify --quiet "refs/heads/$BRANCH_NAME" 2>/dev/null; then
        git -C "$GIT_ROOT" worktree add "$WORKTREE_PATH" "$BRANCH_NAME"
      elif git -C "$GIT_ROOT" show-ref --verify --quiet "refs/remotes/origin/$BRANCH_NAME" 2>/dev/null; then
        git -C "$GIT_ROOT" worktree add --track -b "$BRANCH_NAME" "$WORKTREE_PATH" "origin/$BRANCH_NAME"
      else
        git -C "$GIT_ROOT" worktree add "$WORKTREE_PATH" "$BRANCH_NAME"
      fi
      FINAL_PATH="$(cd "$GIT_ROOT/$WORKTREE_PATH" && pwd)"
      echo "Created worktree at: $FINAL_PATH"
    fi

    echo "Branch: $BRANCH_NAME"
    ;;
esac

# Change to worktree directory and start new shell
if [[ -n "${FINAL_PATH:-}" ]] && [[ -d "$FINAL_PATH" ]]; then
  echo ""
  echo "Changing to: $FINAL_PATH"
  cd "$FINAL_PATH" && exec "$SHELL"
fi
