#!/usr/bin/env bash
# git-wt - Interactive TUI for git worktree management
# Usage: git-wt [OPTIONS] [COMMAND] [BRANCH]
#
# Commands:
#   [BRANCH]          Switch to or create worktree for BRANCH
#   d [BRANCH]        Delete worktree for BRANCH (requires --force if non-interactive)
#
# Options:
#   --scan-dir DIR    Directory to scan for git repos (default: ~/src)
#   --exec            Spawn a new shell in the worktree directory (default in interactive mode)
#   --no-exec         Only print the worktree path (default in non-interactive/CLI mode)
#   --force           Force deletion without confirmation (required for non-interactive delete)
#   -h, --help        Show this help message
#   -v, --version     Show version
#
# Behavior:
#   Interactive (TTY):
#     - No arguments: shows fzf selector for worktrees/branches
#     - With BRANCH: creates/switches to worktree, spawns shell (unless --no-exec)
#     - Delete: shows confirmation prompt (unless --force)
#
#   Non-interactive (no TTY or CLI with args):
#     - No arguments: prints usage and lists worktrees
#     - With BRANCH: prints worktree path (use with: cd "$(git-wt branch)")
#     - Delete: requires --force flag
#
#   Worktrees created at: ../${repo}.worktrees/${branch}

set -euo pipefail

# Version - embedded by release-it during release process
GIT_WT_VERSION="v0.6.3"

# Get version: use git describe only if running from development repo
get_version() {
  local script_path="${BASH_SOURCE[0]}"
  # Resolve symlinks to get actual script location
  while [[ -L "$script_path" ]]; do
    local link_target
    link_target="$(readlink "$script_path")"
    if [[ "$link_target" == /* ]]; then
      script_path="$link_target"
    else
      script_path="$(dirname "$script_path")/$link_target"
    fi
  done
  local script_dir
  script_dir="$(cd "$(dirname "$script_path")/.." && pwd)"

  # Only use git describe if .git exists in repo root (development mode)
  if [[ -d "$script_dir/.git" ]]; then
    git -C "$script_dir" describe --tags --always 2>/dev/null || echo "$GIT_WT_VERSION"
  else
    echo "$GIT_WT_VERSION"
  fi
}

SCAN_DIR="${HOME}/src"
TARGET_BRANCH=""
DELETE_MODE=false
FORCE_DELETE=false
EXEC_SHELL=""  # Empty means use default based on context
UPDATE_CHECK_FILE="/tmp/git-wt-update-check-$$"
PR_CACHE_DIR="/tmp/git-wt-pr-cache-$$"
export PR_CACHE_DIR  # Export for fzf preview subshell

# Detect if running interactively (TTY on stdin)
IS_INTERACTIVE=false
if [[ -t 0 ]] && [[ -t 1 ]]; then
  IS_INTERACTIVE=true
fi

# ANSI color helpers (defined early for use in exit trap)
style_bold() { printf '\033[1m%s\033[0m\n' "$1"; }
style_warn() { printf '\033[38;5;214m%s\033[0m\n' "$1"; }
style_error() { printf '\033[38;5;196m%s\033[0m\n' "$1"; }
style_success() { printf '\033[38;5;82m%s\033[0m\n' "$1"; }
style_bold_error() { printf '\033[1;38;5;196m%s\033[0m\n' "$1"; }

# Background update check - runs asynchronously
check_for_updates() {
  local current_version="$1"
  # Strip leading 'v' if present for comparison
  current_version="${current_version#v}"

  # Skip if current version is 'dev' or empty
  if [[ -z "$current_version" ]] || [[ "$current_version" == "dev" ]]; then
    return
  fi

  # Check GitHub API for latest release (timeout after 2 seconds)
  local latest_info
  if latest_info=$(curl -sf --max-time 2 "https://api.github.com/repos/nsheaps/git-wt/releases/latest" 2>/dev/null); then
    local latest_version
    latest_version=$(echo "$latest_info" | grep -o '"tag_name": *"[^"]*"' | head -1 | sed 's/.*"tag_name": *"v\{0,1\}\([^"]*\)".*/\1/')

    if [[ -n "$latest_version" ]] && [[ "$latest_version" != "$current_version" ]]; then
      # Simple version comparison - check if latest is newer
      # This works for semver: compare as strings after normalizing
      if [[ "$(printf '%s\n%s' "$current_version" "$latest_version" | sort -V | tail -1)" == "$latest_version" ]] && \
         [[ "$current_version" != "$latest_version" ]]; then
        echo "UPDATE_AVAILABLE=$latest_version" > "$UPDATE_CHECK_FILE"
      fi
    fi
  fi
}

# Start background update check
CURRENT_VERSION=$(get_version)
check_for_updates "$CURRENT_VERSION" &
UPDATE_CHECK_PID=$!

# Cleanup and show update notification on exit
cleanup_and_notify() {
  # Cleanup PR cache directory
  rm -rf "$PR_CACHE_DIR" 2>/dev/null || true

  # Wait briefly for background check (non-blocking if already done)
  wait "$UPDATE_CHECK_PID" 2>/dev/null || true

  # Check if update is available
  if [[ -f "$UPDATE_CHECK_FILE" ]]; then
    local update_info
    update_info=$(cat "$UPDATE_CHECK_FILE" 2>/dev/null || true)
    rm -f "$UPDATE_CHECK_FILE" 2>/dev/null || true

    if [[ "$update_info" == UPDATE_AVAILABLE=* ]] && [[ "$IS_INTERACTIVE" == "true" ]]; then
      local new_version="${update_info#UPDATE_AVAILABLE=}"
      echo "" >&2
      style_warn "A new release of git-wt is available: ${CURRENT_VERSION#v} â†’ $new_version" >&2
      echo "To upgrade, run: brew upgrade git-wt" >&2
    fi
  fi
}
trap cleanup_and_notify EXIT

show_help() {
  sed -n '2,28p' "$0" | sed 's/^# //' | sed 's/^#//'
  exit 0
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --scan-dir) SCAN_DIR="$2"; shift 2 ;;
    --exec) EXEC_SHELL="yes"; shift ;;
    --no-exec) EXEC_SHELL="no"; shift ;;
    --force) FORCE_DELETE=true; shift ;;
    -h|--help) show_help ;;
    -v|--version) echo "git-wt $(get_version)"; exit 0 ;;
    d)
      DELETE_MODE=true
      shift
      # Next arg should be the branch name
      if [[ $# -gt 0 ]] && [[ "$1" != -* ]]; then
        TARGET_BRANCH="$1"
        shift
      fi
      ;;
    -*) echo "Unknown option: $1" >&2; show_help ;;
    *)
      TARGET_BRANCH="$1"
      shift
      ;;
  esac
done

# Determine exec behavior based on context
# CLI mode (with branch arg): default to no-exec (print path only)
# Interactive mode (no args, TTY): default to exec (spawn shell)
if [[ -z "$EXEC_SHELL" ]]; then
  if [[ -n "$TARGET_BRANCH" ]]; then
    EXEC_SHELL="no"  # CLI mode: print path by default
  else
    EXEC_SHELL="yes"  # Interactive mode: spawn shell by default
  fi
fi

# Check for required tools
check_tool() {
  if ! command -v "$1" &>/dev/null; then
    echo "Error: $1 is required but not installed" >&2
    case "$1" in
      fzf) echo "Install with: brew install fzf" >&2 ;;
      gum) echo "Install with: brew install gum" >&2 ;;
    esac
    exit 1
  fi
}

# Git is always required
check_tool git

# fzf and gum only required for interactive mode without CLI args
if [[ "$IS_INTERACTIVE" == "true" ]] && [[ -z "$TARGET_BRANCH" ]]; then
  check_tool fzf
  check_tool gum
fi

# Confirm prompt (returns 0 for yes, 1 for no)
confirm() {
  local prompt="${1:-Confirm?}"
  gum confirm "$prompt"
}

# Text input prompt
input_prompt() {
  local placeholder="${1:-Enter value}"
  local result
  result=$(fzf --print-query --header="$placeholder" --height=3 --no-info < /dev/null 2>/dev/null | head -1)
  echo "$result"
}

# Print usage and worktree list for non-interactive mode
show_non_interactive_usage() {
  local git_root="$1"
  local script_name
  script_name=$(basename "$0")

  echo "Usage: $script_name [branch]       Switch to or create worktree"
  echo "       $script_name d [branch]     Delete worktree (requires --force)"
  echo ""
  echo "Options:"
  echo "  --exec      Spawn shell in worktree (instead of printing path)"
  echo "  --force     Force deletion without confirmation"
  echo ""
  echo "Examples:"
  echo "  cd \"\$($script_name feature-branch)\"    # Switch to worktree"
  echo "  $script_name feature-branch --exec      # Switch and spawn shell"
  echo "  $script_name d feature-branch --force   # Delete worktree"
  echo ""

  # List worktrees
  echo "Worktrees:"
  local has_worktrees=false
  while IFS= read -r line; do
    local wt_path="$line"
    local wt_branch
    wt_branch=$(git -C "$wt_path" branch --show-current 2>/dev/null || echo "detached")
    if [[ "$wt_path" == "$git_root" ]]; then
      echo "  [root]     $wt_branch â†’ $wt_path"
    else
      echo "  [worktree] $wt_branch â†’ $wt_path"
    fi
    has_worktrees=true
  done < <(git -C "$git_root" worktree list --porcelain 2>/dev/null | grep "^worktree " | cut -d' ' -f2-)

  if [[ "$has_worktrees" == "false" ]]; then
    echo "  (none)"
  fi

  echo ""
  echo "Branches (without worktrees):"

  # Get branches that don't have worktrees
  declare -A wt_branches
  while IFS= read -r line; do
    local wt_path="$line"
    local wt_branch
    wt_branch=$(git -C "$wt_path" branch --show-current 2>/dev/null || echo "")
    if [[ -n "$wt_branch" ]]; then
      wt_branches["$wt_branch"]=1
    fi
  done < <(git -C "$git_root" worktree list --porcelain 2>/dev/null | grep "^worktree " | cut -d' ' -f2-)

  local has_branches=false
  while IFS= read -r branch; do
    if [[ -n "$branch" ]] && [[ -z "${wt_branches[$branch]:-}" ]]; then
      echo "  $branch"
      has_branches=true
    fi
  done < <(git -C "$git_root" branch --format='%(refname:short)' 2>/dev/null || echo "")

  if [[ "$has_branches" == "false" ]]; then
    echo "  (none)"
  fi
}

# Delete worktree for a branch
delete_worktree() {
  local branch="$1"
  local git_root="$2"
  local force="$3"

  # Find the worktree path for this branch
  local worktree_path=""
  while IFS= read -r line; do
    local wt_path="$line"
    local wt_branch
    wt_branch=$(git -C "$wt_path" branch --show-current 2>/dev/null || echo "")
    if [[ "$wt_branch" == "$branch" ]]; then
      # Don't allow deleting root checkout
      if [[ "$wt_path" == "$git_root" ]]; then
        style_error "Error: Cannot delete root checkout"
        exit 1
      fi
      worktree_path="$wt_path"
      break
    fi
  done < <(git -C "$git_root" worktree list --porcelain 2>/dev/null | grep "^worktree " | cut -d' ' -f2-)

  if [[ -z "$worktree_path" ]]; then
    style_error "Error: No worktree found for branch '$branch'"
    echo "Use '$0' to see available worktrees" >&2
    exit 1
  fi

  echo ""
  style_bold_error "Delete Worktree"
  echo ""
  echo "Branch: $branch"
  echo "Path: $worktree_path"
  echo ""

  # Check if we need confirmation
  local confirmed=false
  if [[ "$force" == "true" ]]; then
    confirmed=true
  elif [[ "$IS_INTERACTIVE" == "true" ]]; then
    if confirm "Are you sure you want to delete this worktree?"; then
      confirmed=true
    fi
  else
    style_error "Error: Non-interactive deletion requires --force flag"
    echo "Run: $0 d $branch --force" >&2
    exit 1
  fi

  if [[ "$confirmed" == "true" ]]; then
    # Try to remove worktree
    if git -C "$git_root" worktree remove "$worktree_path" 2>/dev/null; then
      style_success "âœ“ Worktree deleted successfully"
    else
      # Try force remove if normal remove fails
      echo ""
      style_warn "Worktree has uncommitted changes or other issues."

      local force_confirmed=false
      if [[ "$force" == "true" ]]; then
        force_confirmed=true
      elif [[ "$IS_INTERACTIVE" == "true" ]]; then
        if confirm "Force delete? (will discard any uncommitted changes)"; then
          force_confirmed=true
        fi
      else
        style_error "Error: Force delete required. Run with --force"
        exit 1
      fi

      if [[ "$force_confirmed" == "true" ]]; then
        gum spin --spinner dot --title "Deleting worktree..." -- \
          git -C "$git_root" worktree remove --force "$worktree_path"
        style_success "âœ“ Worktree force deleted"
      else
        echo "Cancelled"
        exit 0
      fi
    fi
  else
    echo "Cancelled"
    exit 0
  fi
}

# Function to find repos in a directory
find_repos_in_dir() {
  local dir="$1"
  if [[ -d "$dir" ]]; then
    find "$dir" -maxdepth 4 -name ".git" -type d 2>/dev/null | while read -r git_dir; do
      dirname "$git_dir"
    done
  fi
}

# Function to select a repo from available options
select_repo() {
  local repos=()

  echo ""
  style_bold "Not in a git repository"
  echo ""

  echo "Scanning $SCAN_DIR for git repos..."

  # Find repos
  while IFS= read -r repo_path; do
    if [[ -n "$repo_path" ]]; then
      repos+=("$repo_path")
    fi
  done < <(find_repos_in_dir "$SCAN_DIR")

  if [[ ${#repos[@]} -eq 0 ]]; then
    echo "No git repositories found in $SCAN_DIR" >&2
    exit 1
  fi

  # Let user select
  SELECTED_REPO=$(printf '%s\n' "${repos[@]}" | fzf --prompt="Select repository> ")
  if [[ -z "$SELECTED_REPO" ]]; then
    echo "Cancelled"
    exit 0
  fi
  echo "$SELECTED_REPO"
}

# Function to create/switch to worktree for a specific branch
switch_to_branch() {
  local branch="$1"
  local git_root="$2"
  local repo_name=$(basename "$git_root")

  # Check if branch exists locally
  local branch_exists_local=false
  if git -C "$git_root" show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null; then
    branch_exists_local=true
  fi

  # Check if branch exists on remote
  local branch_exists_remote=false
  local remote_ref=""
  if git -C "$git_root" show-ref --verify --quiet "refs/remotes/origin/$branch" 2>/dev/null; then
    branch_exists_remote=true
    remote_ref="origin/$branch"
  fi

  # Determine worktree path
  local safe_branch=$(echo "$branch" | tr '/' '-')
  local worktree_path="../${repo_name}.worktrees/${safe_branch}"

  # Check if worktree already exists
  local existing_worktree=""
  while IFS= read -r line; do
    local wt_path=$(echo "$line" | cut -d' ' -f1)
    local wt_branch=$(git -C "$wt_path" branch --show-current 2>/dev/null || echo "")
    if [[ "$wt_branch" == "$branch" ]]; then
      existing_worktree="$wt_path"
      break
    fi
  done < <(git -C "$git_root" worktree list --porcelain 2>/dev/null | grep "^worktree " | cut -d' ' -f2-)

  if [[ -n "$existing_worktree" ]]; then
    echo "Worktree for branch '$branch' already exists at: $existing_worktree"
    echo ""
    echo "WORKTREE_PATH=$existing_worktree"
    return 0
  fi

  # Create worktree directory
  mkdir -p "$(dirname "$git_root/$worktree_path")"

  if [[ "$branch_exists_local" == "true" ]]; then
    # Branch exists locally - create worktree for it
    git -C "$git_root" worktree add "$worktree_path" "$branch"
    echo "Created worktree at: $(cd "$git_root/$worktree_path" && pwd)"
    echo "Branch: $branch (existing local branch)"
  elif [[ "$branch_exists_remote" == "true" ]]; then
    # Branch exists on remote - create tracking worktree
    git -C "$git_root" worktree add --track -b "$branch" "$worktree_path" "$remote_ref"
    echo "Created worktree at: $(cd "$git_root/$worktree_path" && pwd)"
    echo "Branch: $branch (tracking $remote_ref)"
  else
    # Branch doesn't exist - create new branch
    local default_branch=$(git -C "$git_root" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")
    local base_branch="$default_branch"

    if [[ "$IS_INTERACTIVE" == "true" ]]; then
      echo "Branch '$branch' not found locally or on remote."
      echo ""

      # Ask what to base it on
      local base_options=("$default_branch (default)" "other...")
      local base_selected=$(printf '%s\n' "${base_options[@]}" | fzf --header="Create new branch based on:" --height=5 --no-info)

      if [[ "$base_selected" == "other..."* ]]; then
        base_branch=$(git -C "$git_root" branch -a --format='%(refname:short)' | fzf --prompt="Select base branch> ")
      fi
    fi
    # In non-interactive mode, just use default branch silently

    git -C "$git_root" worktree add -b "$branch" "$worktree_path" "$base_branch"
    echo "Created worktree at: $(cd "$git_root/$worktree_path" && pwd)"
    echo "Branch: $branch (new, based on $base_branch)"
  fi

  echo ""
  echo "WORKTREE_PATH=$(cd "$git_root/$worktree_path" && pwd)"
}

# Check if we're in a git repository
IN_GIT_REPO=false
GIT_ROOT=""

if git rev-parse --git-dir &>/dev/null; then
  IN_GIT_REPO=true
  GIT_ROOT=$(git rev-parse --show-toplevel)
fi

# If not in a git repo, behavior depends on mode
if [[ "$IN_GIT_REPO" == "false" ]]; then
  if [[ "$IS_INTERACTIVE" == "true" ]] && [[ -z "$TARGET_BRANCH" ]]; then
    # Interactive mode without target: prompt for repo
    GIT_ROOT=$(select_repo)
    if [[ -z "$GIT_ROOT" ]] || [[ ! -d "$GIT_ROOT" ]]; then
      echo "No repository selected"
      exit 1
    fi
    IN_GIT_REPO=true
    cd "$GIT_ROOT"
  else
    # Non-interactive or CLI mode: error
    style_error "Error: Not in a git repository"
    echo "Run from within a git repository" >&2
    exit 1
  fi
fi

# Get repo info
REPO_NAME=$(basename "$GIT_ROOT")

# Check if we're in a worktree (not the main checkout)
GIT_DIR=$(git -C "$GIT_ROOT" rev-parse --git-dir)
if [[ "$GIT_DIR" == *".git/worktrees/"* ]]; then
  # We're in a worktree - find the main checkout and use that for operations
  MAIN_CHECKOUT=$(git -C "$GIT_ROOT" rev-parse --path-format=absolute --git-common-dir | sed 's|/.git$||')
  GIT_ROOT="$MAIN_CHECKOUT"
  REPO_NAME=$(basename "$GIT_ROOT")
fi

# Handle delete mode first (before fetch, since we don't need remote info)
if [[ "$DELETE_MODE" == "true" ]]; then
  if [[ -z "$TARGET_BRANCH" ]]; then
    style_error "Error: Branch name required for delete"
    echo "Usage: $0 d <branch> [--force]" >&2
    exit 1
  fi
  delete_worktree "$TARGET_BRANCH" "$GIT_ROOT" "$FORCE_DELETE"
  exit 0
fi

# Handle non-interactive mode without target branch (list worktrees)
if [[ "$IS_INTERACTIVE" == "false" ]] && [[ -z "$TARGET_BRANCH" ]]; then
  show_non_interactive_usage "$GIT_ROOT"
  exit 0
fi

# Fetch from remote (only for switch operations)
if [[ "$EXEC_SHELL" == "yes" ]] || [[ -z "$TARGET_BRANCH" ]]; then
  # Interactive mode or spawning shell - show fetch output
  echo ""
  echo "Fetching from remote..."
  git -C "$GIT_ROOT" fetch origin --prune 2>/dev/null || true
else
  # CLI mode printing path only - silent fetch
  git -C "$GIT_ROOT" fetch origin --prune 2>/dev/null || true
fi

# Setup for PR preview caching
mkdir -p "$PR_CACHE_DIR"
export GIT_ROOT  # Export for fzf preview subshell

# If branch specified via CLI, create/switch to that worktree
if [[ -n "$TARGET_BRANCH" ]]; then
  # Capture output to extract path
  OUTPUT=$(switch_to_branch "$TARGET_BRANCH" "$GIT_ROOT" 2>&1)

  # Extract the worktree path from output
  FINAL_PATH=$(echo "$OUTPUT" | grep "WORKTREE_PATH=" | sed 's/WORKTREE_PATH=//')

  if [[ "$EXEC_SHELL" == "yes" ]]; then
    # Show all output and spawn shell
    echo "$OUTPUT" | grep -v "WORKTREE_PATH="
    if [[ -n "$FINAL_PATH" ]] && [[ -d "$FINAL_PATH" ]]; then
      echo ""
      echo "Changing to: $FINAL_PATH"
      cd "$FINAL_PATH" && exec "$SHELL"
    fi
  else
    # Just print the path (for use with cd "$(git-wt branch)")
    if [[ -n "$FINAL_PATH" ]]; then
      echo "$FINAL_PATH"
    else
      # No path found, print error output
      echo "$OUTPUT" >&2
      exit 1
    fi
  fi
  exit 0
fi

# Interactive mode - offer worktree selection
echo ""
style_bold "Git Worktree Selector"
echo ""

# Get existing worktrees (including root checkout) and track their branches
WORKTREES=()
ROOT_CHECKOUT=""
declare -A WORKTREE_BRANCHES
while IFS= read -r line; do
  # Track root checkout separately so it appears first
  if [[ "$line" == "$GIT_ROOT" ]]; then
    ROOT_CHECKOUT="$line"
  else
    WORKTREES+=("$line")
  fi
  # Track which branch this worktree is on for deduplication
  local_branch=$(git -C "$line" branch --show-current 2>/dev/null || echo "")
  if [[ -n "$local_branch" ]]; then
    WORKTREE_BRANCHES["$local_branch"]=1
  fi
done < <(git -C "$GIT_ROOT" worktree list --porcelain | grep "^worktree " | cut -d' ' -f2-)

# Build branch list from local branches only (excluding branches with existing worktrees)
declare -A BRANCHES

# Get local branches
while IFS= read -r branch; do
  if [[ -n "$branch" ]] && [[ -z "${WORKTREE_BRANCHES[$branch]:-}" ]]; then
    BRANCHES["$branch"]=1
  fi
done < <(git -C "$GIT_ROOT" branch --format='%(refname:short)' 2>/dev/null || echo "")

# Build menu options
MENU_OPTIONS=()
MENU_OPTIONS+=("ðŸ“ (create new worktree)")

# Add root checkout first (if found)
if [[ -n "$ROOT_CHECKOUT" ]]; then
  root_branch=$(git -C "$ROOT_CHECKOUT" branch --show-current 2>/dev/null || echo "detached")
  MENU_OPTIONS+=("ðŸ  [root] $root_branch â†’ $ROOT_CHECKOUT")
fi

# Add existing worktrees
for wt in "${WORKTREES[@]}"; do
  wt_branch=$(git -C "$wt" branch --show-current 2>/dev/null || echo "detached")
  MENU_OPTIONS+=("ðŸ“‚ [worktree] $wt_branch â†’ $wt")
done

# Add branches (sorted)
for branch in $(echo "${!BRANCHES[@]}" | tr ' ' '\n' | sort); do
  MENU_OPTIONS+=("$branch")
done

# Add option to switch repo (step "up")
MENU_OPTIONS+=("ðŸ”„ (switch repository)")

# Show selection menu with fzf
# Preview shows PR info from cache, falls back to single fetch if not cached yet
KEY_PRESSED=""
FZF_RESULT=$(printf '%s\n' "${MENU_OPTIONS[@]}" | fzf \
  --style=full \
  --expect=d \
  --no-sort \
  --header="enter=select, d=delete worktree" \
  --prompt="Select or create worktree> " \
  --preview='
    item={}
    # Extract branch name from different formats
    if [[ "$item" == "ðŸ“‚ [worktree]"* ]] || [[ "$item" == "ðŸ  [root]"* ]]; then
      branch=$(echo "$item" | sed "s/^[^ ]* \[[^]]*\] //" | sed "s/ â†’.*//")
    elif [[ "$item" == "ðŸ“"* ]] || [[ "$item" == "ðŸ”„"* ]]; then
      echo "No preview available"
      exit 0
    else
      branch="$item"
    fi

    # Read from cache if available
    safe_branch=$(echo "$branch" | tr "/" "_")
    cache_file="$PR_CACHE_DIR/$safe_branch"

    if [[ -f "$cache_file" ]]; then
      cat "$cache_file"
    elif command -v gh &>/dev/null; then
      # Cache miss - fetch just this branch from correct repo context
      cd "$GIT_ROOT" 2>/dev/null || true
      result=$(gh pr view "$branch" 2>&1)
      if [[ $? -eq 0 ]]; then
        echo "$result" | tee "$cache_file"
      else
        echo "No PR found for branch: $branch" | tee "$cache_file"
      fi
    else
      echo "No PR found for branch: $branch"
    fi
  ' \
  --preview-window=right:50%:wrap)
KEY_PRESSED=$(echo "$FZF_RESULT" | head -1)
SELECTED=$(echo "$FZF_RESULT" | tail -1)

if [[ -z "$SELECTED" ]]; then
  echo "Cancelled"
  exit 0
fi

# Handle 'd' key press for delete
if [[ "$KEY_PRESSED" == "d" ]]; then
  # Only allow deleting worktrees (not root, not create option, not branches)
  if [[ "$SELECTED" != "ðŸ“‚ [worktree]"* ]]; then
    echo ""
    style_warn "Cannot delete: only worktrees can be deleted with 'd'"
    echo "Selected item: $SELECTED"
    exit 1
  fi

  # Extract worktree path
  WT_PATH=$(echo "$SELECTED" | sed 's/.*â†’ //')
  WT_BRANCH=$(echo "$SELECTED" | sed 's/ðŸ“‚ \[worktree\] //' | sed 's/ â†’.*//')

  echo ""
  style_bold_error "Delete Worktree"
  echo ""
  echo "Branch: $WT_BRANCH"
  echo "Path: $WT_PATH"
  echo ""

  if confirm "Are you sure you want to delete this worktree?"; then
    # Remove the worktree
    if git -C "$GIT_ROOT" worktree remove "$WT_PATH" 2>/dev/null; then
      echo ""
      style_success "âœ“ Worktree deleted successfully"
    else
      # Try force remove if normal remove fails
      echo ""
      style_warn "Worktree has uncommitted changes or other issues."
      if confirm "Force delete? (will discard any uncommitted changes)"; then
        gum spin --spinner dot --title "Deleting worktree..." -- \
          git -C "$GIT_ROOT" worktree remove --force "$WT_PATH"
        style_success "âœ“ Worktree force deleted"
      else
        echo "Cancelled"
      fi
    fi
  else
    echo "Cancelled"
  fi
  exit 0
fi

# Handle selection
case "$SELECTED" in
  "ðŸ“ (create new worktree)")
    # Get branch name
    BRANCH_NAME=$(input_prompt "Enter new branch name")
    if [[ -z "$BRANCH_NAME" ]]; then
      echo "Cancelled"
      exit 0
    fi

    # Ask for base branch
    CURRENT_BRANCH=$(git -C "$GIT_ROOT" branch --show-current)
    DEFAULT_BRANCH=$(git -C "$GIT_ROOT" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")

    BASE_OPTIONS=("$DEFAULT_BRANCH (default)" "$CURRENT_BRANCH (current)" "other...")
    BASE_SELECTED=$(printf '%s\n' "${BASE_OPTIONS[@]}" | fzf --header="Base branch:" --height=6 --no-info)

    case "$BASE_SELECTED" in
      *"(default)"*) BASE_BRANCH="$DEFAULT_BRANCH" ;;
      *"(current)"*) BASE_BRANCH="$CURRENT_BRANCH" ;;
      *) BASE_BRANCH=$(git -C "$GIT_ROOT" branch -a --format='%(refname:short)' | fzf --prompt="Select base branch> ") ;;
    esac

    # Create worktree path
    SAFE_BRANCH=$(echo "$BRANCH_NAME" | tr '/' '-')
    WORKTREE_PATH="../${REPO_NAME}.worktrees/${SAFE_BRANCH}"

    # Create the worktree
    mkdir -p "$(dirname "$GIT_ROOT/$WORKTREE_PATH")"
    git -C "$GIT_ROOT" worktree add -b "$BRANCH_NAME" "$WORKTREE_PATH" "$BASE_BRANCH"

    FINAL_PATH="$(cd "$GIT_ROOT/$WORKTREE_PATH" && pwd)"
    echo ""
    echo "Created worktree at: $FINAL_PATH"
    echo "Branch: $BRANCH_NAME (based on $BASE_BRANCH)"
    ;;

  "ðŸ  [root]"*)
    # Extract path from selection
    FINAL_PATH=$(echo "$SELECTED" | sed 's/.*â†’ //')
    echo ""
    echo "Selected root checkout: $FINAL_PATH"
    ;;

  "ðŸ“‚ [worktree]"*)
    # Extract path from selection
    FINAL_PATH=$(echo "$SELECTED" | sed 's/.*â†’ //')
    echo ""
    echo "Selected worktree: $FINAL_PATH"
    ;;

  "ðŸ”„ (switch repository)")
    # Reset and re-run with repo selection
    NEW_REPO=$(select_repo)
    if [[ -n "$NEW_REPO" ]] && [[ -d "$NEW_REPO" ]]; then
      exec "$0" --scan-dir "$SCAN_DIR"
    fi
    ;;

  *)
    # Selected an existing branch - create worktree for it
    BRANCH_NAME="$SELECTED"

    SAFE_BRANCH=$(echo "$BRANCH_NAME" | tr '/' '-')
    WORKTREE_PATH="../${REPO_NAME}.worktrees/${SAFE_BRANCH}"

    if [[ -d "$GIT_ROOT/$WORKTREE_PATH" ]]; then
      FINAL_PATH="$(cd "$GIT_ROOT/$WORKTREE_PATH" && pwd)"
      echo "Worktree already exists at: $FINAL_PATH"
    else
      mkdir -p "$(dirname "$GIT_ROOT/$WORKTREE_PATH")"

      # Check if branch exists locally or only on remote
      if git -C "$GIT_ROOT" show-ref --verify --quiet "refs/heads/$BRANCH_NAME" 2>/dev/null; then
        git -C "$GIT_ROOT" worktree add "$WORKTREE_PATH" "$BRANCH_NAME"
      elif git -C "$GIT_ROOT" show-ref --verify --quiet "refs/remotes/origin/$BRANCH_NAME" 2>/dev/null; then
        git -C "$GIT_ROOT" worktree add --track -b "$BRANCH_NAME" "$WORKTREE_PATH" "origin/$BRANCH_NAME"
      else
        git -C "$GIT_ROOT" worktree add "$WORKTREE_PATH" "$BRANCH_NAME"
      fi
      FINAL_PATH="$(cd "$GIT_ROOT/$WORKTREE_PATH" && pwd)"
      echo "Created worktree at: $FINAL_PATH"
    fi

    echo "Branch: $BRANCH_NAME"
    ;;
esac

# Change to worktree directory and start new shell
if [[ -n "${FINAL_PATH:-}" ]] && [[ -d "$FINAL_PATH" ]]; then
  echo ""
  echo "Changing to: $FINAL_PATH"
  cd "$FINAL_PATH" && exec "$SHELL"
fi
